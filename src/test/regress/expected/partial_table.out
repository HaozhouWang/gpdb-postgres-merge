-- TODO: inherit tables
-- TODO: partition tables
-- TODO: ao tables
-- TODO: tables and temp tables
\set explain 'explain analyze'
create extension if not exists gp_debug_numsegments;
drop schema if exists test_partial_table;
NOTICE:  schema "test_partial_table" does not exist, skipping
create schema test_partial_table;
set search_path=test_partial_table,public;
set allow_system_table_mods=true;
--
-- prepare kinds of tables
--
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t1 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d1 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r1 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table t2 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d2 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r2 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in (
		't1'::regclass, 'd1'::regclass, 'r1'::regclass,
		't2'::regclass, 'd2'::regclass, 'r2'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t1       | 1 2     | p          |           1
 d1       |         | r          |           1
 r1       |         | p          |           1
 t2       | 1 2     | p          |           2
 d2       |         | r          |           2
 r2       |         | p          |           2
(6 rows)

analyze t1;
analyze d1;
analyze r1;
analyze t2;
analyze d2;
analyze r2;
--
-- regression tests
--
-- Test numsegments properity cannot be larger than the size of cluster
create table size_sanity_check(c1 int, c2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
update gp_distribution_policy set numsegments = 10 where localoid = 'size_sanity_check'::regclass;
select * from size_sanity_check;
ERROR:  cannot access table "size_sanity_check" in current transaction
LINE 1: select * from size_sanity_check;
                      ^
DETAIL:  New segments are concurrently added to the cluster during the execution of current transaction, the table has data on some of the new segments, but these new segments are invisible and inaccessible to current transaction.
HINT:  Re-run the query in a new transaction.
update gp_distribution_policy set numsegments = 3 where localoid = 'size_sanity_check'::regclass;
-- a temp table is created during reorganization, its numsegments should be
-- the same with original table, otherwise some data will be lost after the
-- reorganization.
--
-- in most cases the temp table is created with CTAS.
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

abort;
-- but there are also cases the temp table is created with CREATE + INSERT.
-- case 1: with dropped columns
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	alter table t1 drop column c4;
	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 
---------------+----+----+----
             0 |  1 |  1 |   
             0 |  2 |  2 |   
             0 |  3 |  3 |   
             0 |  4 |  4 |   
             0 |  5 |  5 |   
             0 |  6 |  6 |   
             0 |  7 |  7 |   
             0 |  8 |  8 |   
             0 |  9 |  9 |   
             0 | 10 | 10 |   
(10 rows)

abort;
-- case 2: AOCO
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=column)
	  distributed by (c1, c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- case 3: AO + index
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=row)
	  distributed by (c1, c2);
	create index ti on t (c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- restore the analyze information
analyze t1;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- append SingleQE of different sizes
select max(c1) as v, 1 as r from t2 union all select 1 as v, 2 as r;
 v | r 
---+---
   | 1
 1 | 2
(2 rows)

-- append node should use the max numsegments of all the subpaths
begin;
	-- insert enough data to ensure executors got reached on segments
	insert into t1 select i from generate_series(1,100) i;
	insert into t2 select i from generate_series(1,100) i;
	:explain  select * from t2 a join t2 b using(c2)
	union all select * from t1 c join t1 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=6.25..17.52 rows=14 width=28) (actual time=2.573..2.573 rows=0 loops=2)
   ->  Append  (cost=6.25..17.52 rows=5 width=28) (actual time=0.000..4.405 rows=0 loops=1)
         ->  Hash Join  (cost=6.25..11.69 rows=3 width=28) (actual time=0.000..3.522 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     Hash Key: a.c2
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=34 width=16) (actual time=0.010..0.019 rows=28 loops=2)
               ->  Hash  (cost=5.00..5.00 rows=34 width=16) (actual time=0.000..1.184 rows=0 loops=1)
                     ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (actual time=0.018..0.585 rows=50 loops=2)
                           Hash Key: b.c2
                           ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=34 width=16) (actual time=0.007..0.015 rows=28 loops=2)
         ->  Hash Join  (cost=3.25..5.69 rows=3 width=28) (actual time=0.000..1.404 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Seq Scan on t1 c  (cost=0.00..2.00 rows=34 width=16) (actual time=0.012..0.012 rows=0 loops=2)
               ->  Hash  (cost=2.00..2.00 rows=34 width=16) (actual time=0.000..0.056 rows=0 loops=1)
                     ->  Seq Scan on t1 d  (cost=0.00..2.00 rows=34 width=16) (actual time=0.009..0.022 rows=50 loops=2)
 Planning time: 1.964 ms
   (slice0)    Executor memory: 518K bytes.
   (slice1)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 3244K bytes avg x 2 workers, 4270K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 9.956 ms
(26 rows)

	:explain  select * from t1 a join t1 b using(c2)
	union all select * from t2 c join t2 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3.25..17.52 rows=14 width=28) (actual time=1.483..1.483 rows=0 loops=2)
   ->  Append  (cost=3.25..17.52 rows=5 width=28) (actual time=0.000..2.279 rows=0 loops=1)
         ->  Hash Join  (cost=3.25..5.69 rows=3 width=28) (actual time=0.000..0.827 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Seq Scan on t1 a  (cost=0.00..2.00 rows=34 width=16) (actual time=0.006..0.006 rows=0 loops=2)
               ->  Hash  (cost=2.00..2.00 rows=34 width=16) (actual time=0.000..0.043 rows=0 loops=1)
                     ->  Seq Scan on t1 b  (cost=0.00..2.00 rows=34 width=16) (actual time=0.004..0.015 rows=50 loops=2)
         ->  Hash Join  (cost=6.25..11.69 rows=3 width=28) (actual time=0.000..2.221 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     Hash Key: c.c2
                     ->  Seq Scan on t2 c  (cost=0.00..3.00 rows=34 width=16) (actual time=0.010..0.018 rows=28 loops=2)
               ->  Hash  (cost=5.00..5.00 rows=34 width=16) (actual time=0.000..0.915 rows=0 loops=1)
                     ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (actual time=0.266..0.449 rows=50 loops=2)
                           Hash Key: d.c2
                           ->  Seq Scan on t2 d  (cost=0.00..3.00 rows=34 width=16) (actual time=0.006..0.013 rows=28 loops=2)
 Planning time: 1.493 ms
   (slice0)    Executor memory: 518K bytes.
   (slice1)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 3232K bytes avg x 2 workers, 4258K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 3.839 ms
(26 rows)

abort;
-- partitioned table should have the same numsegments for parent and children
-- even in RANDOM mode.
select gp_debug_set_create_table_default_numsegments('random');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 RANDOM
(1 row)

begin;
	create table t (c1 int, c2 int) distributed by (c1)
	partition by range(c2) (start(0) end(20) every(1));
	-- verify that parent and children have the same numsegments
	select count(a.localoid)
	  from gp_distribution_policy a
	  join pg_class c
	    on a.localoid = c.oid
	   and c.relname like 't_1_prt_%'
	  join gp_distribution_policy b
	    on a.numsegments = b.numsegments
	   and b.localoid = 't'::regclass
	;
 count 
-------
    20
(1 row)

abort;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- verify numsegments in subplans
:explain select * from t1, t2
   where t1.c1 > any (select max(t2.c1) from t2 where t2.c2 = t1.c2)
     and t2.c1 > any (select max(t1.c1) from t1 where t1.c2 = t2.c2);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=10000000000.00..10000000006.41 rows=50 width=32) (actual time=1.472..1.472 rows=0 loops=1)
   ->  Nested Loop  (cost=10000000000.00..10000000005.41 rows=25 width=32) (never executed)
         ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
               ->  Seq Scan on t1  (cost=0.00..1.00 rows=1 width=16) (never executed)
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Aggregate  (cost=6.75..6.76 rows=1 width=4) (never executed)
                             ->  Result  (cost=0.00..6.50 rows=100 width=4) (never executed)
                                   Filter: (t2_1.c2 = t1.c2)
                                   ->  Materialize  (cost=0.00..5.50 rows=100 width=8) (never executed)
                                         ->  Broadcast Motion 2:1  (slice3; segments: 2)  (cost=0.00..5.00 rows=50 width=8) (never executed)
                                               ->  Seq Scan on t2 t2_1  (cost=0.00..3.00 rows=50 width=8) (never executed)
         ->  Materialize  (cost=0.00..3.25 rows=25 width=16) (never executed)
               ->  Seq Scan on t2  (cost=0.00..3.00 rows=25 width=16) (never executed)
                     Filter: (SubPlan 2)
                     SubPlan 2
                       ->  Aggregate  (cost=1.04..1.05 rows=1 width=4) (never executed)
                             ->  Result  (cost=0.00..1.03 rows=1 width=4) (never executed)
                                   Filter: (t1_1.c2 = t2.c2)
                                   ->  Materialize  (cost=0.00..1.02 rows=1 width=8) (never executed)
                                         ->  Broadcast Motion 1:2  (slice4; segments: 1)  (cost=0.00..1.02 rows=1 width=8) (never executed)
                                               ->  Seq Scan on t1 t1_1  (cost=0.00..1.00 rows=1 width=8) (never executed)
 Planning Time: 2.244 ms
   (slice0)    Executor memory: 90K bytes.
   (slice1)    Executor memory: 55K bytes avg x 2 workers, 55K bytes max (seg0).
   (slice2)    Executor memory: 51K bytes (seg0).
   (slice3)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice4)    Executor memory: 38K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 10.056 ms
(31 rows)

--
-- It is used to test this case:
--   A: replicated table, distributed on 2 segments
--   B: replicated table, distributed on 1 segments
--   UPDATE A SET XXX FROM B WHERE XXX;
-- We have to add a broadcast motion on B so that A can update/delete correctly.
--
begin;
    insert into d1 select i,i,i,i from generate_series(1,2) i;
    insert into d2 select i,i,i,i from generate_series(1,3) i;
    explain update d2 a set c3=b.c3 from d1 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 2:1  (slice2; segments: 2)  (cost=10000000000.00..10000000002.08 rows=4 width=44)
   ->  Update on d2 a  (cost=10000000000.00..10000000002.08 rows=2 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.08 rows=2 width=44)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=22)
               ->  Materialize  (cost=0.00..1.05 rows=1 width=22)
                     ->  Broadcast Motion 1:2  (slice1; segments: 1)  (cost=0.00..1.04 rows=3 width=22)
                           ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=22)
 Planning time: 0.915 ms
 Optimizer: Postgres query optimizer
(9 rows)

    update d2 a set c3=b.c3 from d1 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
  3 |  3 |  1 |  3 |  1 |  1 |  1 |  1
(3 rows)

    explain update d1 a set c3=b.c3 from d2 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000002.13..10000000002.13 rows=6 width=44)
   ->  Update on d1 a  (cost=10000000000.00..10000000002.13 rows=6 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.13 rows=6 width=44)
               ->  Seq Scan on d1 a  (cost=0.00..1.02 rows=2 width=22)
               ->  Materialize  (cost=0.00..1.04 rows=3 width=22)
                     ->  Seq Scan on d2 b  (cost=0.00..1.03 rows=3 width=22)
 Optimizer: Postgres query optimizer
(7 rows)

    update d1 a set c3=b.c3 from d2 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
(2 rows)

abort;
-- restore the analyze information
analyze d1;
analyze d2;
--
-- create table: LIKE, INHERITS and DISTRIBUTED BY
--
-- tables are always created with DEFAULT as numsegments,
-- no matter there is LIKE, INHERITS or DISTRIBUTED BY.
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

-- none of the clauses
create table t ();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY only
create table t () distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS only
create table t () inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- LIKE only
create table t (like d1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS
create table t () inherits (t2) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + LIKE
create table t (like d1) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS + LIKE
create table t (like d1) inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS + LIKE
create table t (like d1) inherits (t2) distributed randomly;
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS from multiple parents
create table t () inherits (r1, t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS from multiple parents
create table t () inherits (r1, t2) distributed by (c1);
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1       | p          |           2
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- CTAS set numsegments with DEFAULT,
-- let it be a fixed value to get stable output
select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

create table t as table t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           3
(1 row)

drop table t;
select * into table t from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

--
-- alter table
--
-- numsegments should not be changed
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t (like t1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t set distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           1
(1 row)

alter table t set distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           1
(1 row)

alter table t set distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t add column c10 int;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t alter column c10 type text;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- below join cases cover all the combinations of
--
--     select * from {t,d,r}{1,2} a
--      {left,} join {t,d,r}{1,2} b
--      using (c1{',c2',});
--
-- there might be some duplicated ones, like 't1 join d1' and 'd1 join t1',
-- or 'd1 join r1 using (c1)' and 'd1 join r1 using (c1, c2)', this is because
-- we generate them via scripts and do not clean them up manually.
--
-- please do not remove the duplicated ones as we care about the motion
-- direction of different join orders, e.g. 't2 join t1' and 't1 join t2'
-- should both distribute t2 to t1.
--
-- JOIN
--
-- x1 join y1
:explain select * from t1 a join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.239..0.239 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.089 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.088 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.541 ms
(13 rows)

:explain select * from t1 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.247..0.247 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.148 ms
(11 rows)

:explain select * from t1 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.239..0.239 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.205 ms
(11 rows)

:explain select * from t1 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.179..0.179 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.027 ms
(11 rows)

:explain select * from t1 a join r1 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1080.77 rows=72 width=28) (actual time=0.891..0.892 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1079.35 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.962 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.951 ms
(12 rows)

:explain select * from t1 a join r1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1345.75 rows=17 width=24) (actual time=0.941..0.942 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1345.43 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.205 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.085 ms
(12 rows)

:explain select * from d1 a join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.205..0.205 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.103 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.103 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.165 ms
(11 rows)

:explain select * from d1 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.181..0.181 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.223 ms
(11 rows)

:explain select * from d1 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.197..0.197 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.053 ms
(11 rows)

:explain select * from d1 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.198..0.198 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.028 ms
(11 rows)

:explain select * from d1 a join r1 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1080.77 rows=72 width=28) (actual time=0.917..0.918 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1079.35 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.707 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 1.964 ms
(12 rows)

:explain select * from d1 a join r1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1345.75 rows=17 width=24) (actual time=0.918..0.918 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1345.43 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.826 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.038 ms
(12 rows)

:explain select * from r1 a join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.222..0.222 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.008 ms
(13 rows)

:explain select * from r1 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.210..0.210 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.149 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.148 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.638 ms
(14 rows)

:explain select * from r1 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.094 ms
(11 rows)

:explain select * from r1 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.032 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.031 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.085 ms
(11 rows)

:explain select * from r1 a join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.220..0.220 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.583 ms
(13 rows)

:explain select * from r1 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.198..0.198 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.447 ms
(13 rows)

-- x1 join y2
:explain select * from t1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.05..4.63 rows=7 width=28) (actual time=4.675..4.675 rows=0 loops=1)
   ->  Hash Join  (cost=1.05..4.50 rows=4 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.168 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4118K bytes avg x 2 workers, 4118K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 5.783 ms
(14 rows)

:explain select * from t1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..4.98 rows=7 width=24) (actual time=5.658..5.659 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..4.85 rows=4 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.724 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 7.266 ms
(15 rows)

:explain select * from t1 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.314..0.314 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.370 ms
(11 rows)

:explain select * from t1 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.190..0.190 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.071 ms
(11 rows)

:explain select * from t1 a join r2 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.05..1080.81 rows=72 width=28) (actual time=2.496..2.497 rows=0 loops=1)
   ->  Hash Join  (cost=1.05..1079.39 rows=36 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.578 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4117K bytes avg x 2 workers, 4117K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.969 ms
(14 rows)

:explain select * from t1 a join r2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.06..1345.79 rows=17 width=24) (actual time=2.473..2.473 rows=0 loops=1)
   ->  Hash Join  (cost=1.06..1345.47 rows=9 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.626 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.912 ms
(14 rows)

:explain select * from d1 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..6.61 rows=7 width=28) (actual time=2.556..2.557 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..6.47 rows=7 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.213 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.179 ms
(18 rows)

:explain select * from d1 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..4.98 rows=7 width=24) (actual time=2.288..2.289 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..4.85 rows=4 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.254 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.783 ms
(15 rows)

:explain select * from d1 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.214..0.214 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.036 ms
(11 rows)

:explain select * from d1 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.209..0.209 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.005 ms
(11 rows)

:explain select * from d1 a join r2 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2502.79 rows=72 width=28) (actual time=3.239..3.239 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..2501.37 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..2233.00 rows=35550 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.460 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.671 ms
(18 rows)

:explain select * from d1 a join r2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2767.77 rows=17 width=24) (actual time=3.000..3.001 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..2767.45 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..2233.00 rows=35550 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.657 ms
   (slice0)    Executor memory: 47K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.523 ms
(18 rows)

:explain select * from r1 a join t2 b using (c1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=6.25..1217.22 rows=7110 width=28) (actual time=3.005..3.006 rows=0 loops=1)
   ->  Hash Join  (cost=6.25..1075.02 rows=7110 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.549 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4118K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.514 ms
(14 rows)

:explain select * from r1 a join t2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=6.50..1191.32 rows=17 width=24) (actual time=2.907..2.908 rows=0 loops=1)
   ->  Hash Join  (cost=6.50..1191.00 rows=17 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.652 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.310 ms
(14 rows)

:explain select * from r1 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.294..0.294 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.073 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.073 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.169 ms
(11 rows)

:explain select * from r1 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.199..0.199 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.019 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.995 ms
(11 rows)

:explain select * from r1 a join r2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.734..1.734 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.483 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.364 ms
(13 rows)

:explain select * from r1 a join r2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..3798057.05 rows=5056 width=24) (actual time=1.571..1.571 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..3798057.05 rows=1686 width=24) (actual time=0.000..2.437 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.029 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.028 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.899 ms
(13 rows)

-- x2 join y1
:explain select * from t2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.05..4.63 rows=7 width=28) (actual time=2.264..2.264 rows=0 loops=1)
   ->  Hash Join  (cost=1.05..4.50 rows=4 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.142 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4117K bytes avg x 2 workers, 4117K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.770 ms
(14 rows)

:explain select * from t2 a join t1 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=3299.50..1268319.05 rows=5056 width=24) (actual time=1.479..1.479 rows=0 loops=2)
   ->  Hash Join  (cost=3299.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.556 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (never executed)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..0.635 rows=0 loops=1)
               ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.633 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.722 ms
(14 rows)

:explain select * from t2 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.09 rows=4 width=28) (actual time=3.444..3.444 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..2.09 rows=2 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 0.956 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes avg x 2 workers, 44K bytes max (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 4.686 ms
(18 rows)

:explain select * from t2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..4.98 rows=7 width=24) (actual time=2.293..2.293 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..4.85 rows=4 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.187 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.741 ms
(15 rows)

:explain select * from t2 a join r1 b using (c1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=6.25..1217.22 rows=7110 width=28) (actual time=2.932..2.932 rows=0 loops=1)
   ->  Hash Join  (cost=6.25..1075.02 rows=7110 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.566 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.339 ms
(14 rows)

:explain select * from t2 a join r1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=6.50..1191.32 rows=17 width=24) (actual time=3.113..3.113 rows=0 loops=1)
   ->  Hash Join  (cost=6.50..1191.00 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 3.182 ms
   (slice0)    Executor memory: 44K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 5.030 ms
(14 rows)

:explain select * from d2 a join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..2.12 rows=4 width=28) (actual time=1.303..1.303 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..2.05 rows=4 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.090 ms
   (slice0)    Executor memory: 42K bytes.
   (slice1)    Executor memory: 41K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.912 ms
(12 rows)

:explain select * from d2 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.196..0.196 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.001 ms
(11 rows)

:explain select * from d2 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.192..0.192 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.951 ms
(11 rows)

:explain select * from d2 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.202..0.202 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.014 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.969 ms
(11 rows)

:explain select * from d2 a join r1 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1080.77 rows=72 width=28) (actual time=1.555..1.555 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1079.35 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.940 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.021 ms
(12 rows)

:explain select * from d2 a join r1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1345.75 rows=17 width=24) (actual time=1.069..1.069 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1345.43 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.070 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.396 ms
(12 rows)

:explain select * from r2 a join t1 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.05..1080.81 rows=72 width=28) (actual time=2.380..2.380 rows=0 loops=1)
   ->  Hash Join  (cost=1.05..1079.39 rows=36 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.701 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4117K bytes avg x 2 workers, 4117K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.939 ms
(14 rows)

:explain select * from r2 a join t1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.06..1345.79 rows=17 width=24) (actual time=2.674..2.674 rows=0 loops=1)
   ->  Hash Join  (cost=1.06..1345.47 rows=9 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.615 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.167 ms
(14 rows)

:explain select * from r2 a join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.09 rows=4 width=28) (actual time=3.489..3.489 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..2.09 rows=2 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 0.786 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes avg x 2 workers, 44K bytes max (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 3.907 ms
(18 rows)

:explain select * from r2 a join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.10 rows=4 width=24) (actual time=3.558..3.558 rows=0 loops=1)
   ->  Hash Join  (cost=1.03..2.10 rows=2 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 1.124 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes avg x 2 workers, 44K bytes max (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: legacy query optimizer
 Execution time: 4.281 ms
(18 rows)

:explain select * from r2 a join r1 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.328..1.328 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.378 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.032 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.497 ms
(13 rows)

:explain select * from r2 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..3798057.05 rows=5056 width=24) (actual time=1.363..1.363 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..3798057.05 rows=1686 width=24) (actual time=0.000..2.437 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.035 rows=0 loops=1)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.561 ms
(13 rows)

-- x2 join y2
:explain select * from t2 a join t2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.625..2.625 rows=0 loops=2)
   ->  Hash Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..4.832 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.012 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..3.169 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..3.167 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.024 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 12.201 ms
(17 rows)

:explain select * from t2 a join t2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.189..0.189 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.957 ms
(11 rows)

:explain select * from t2 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.287..0.287 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.908 ms
(11 rows)

:explain select * from t2 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.312..0.312 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.960 ms
(11 rows)

:explain select * from t2 a join r2 b using (c1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=8.50..1219.47 rows=7110 width=28) (actual time=3.089..3.090 rows=0 loops=1)
   ->  Hash Join  (cost=8.50..1077.27 rows=3555 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=6.00..6.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:2  (slice2; segments: 2)  (cost=0.00..6.00 rows=100 width=16) (never executed)
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.601 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4117K bytes avg x 2 workers, 4117K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.731 ms
(14 rows)

:explain select * from t2 a join r2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=9.00..1193.82 rows=17 width=24) (actual time=3.340..3.340 rows=0 loops=1)
   ->  Hash Join  (cost=9.00..1193.50 rows=9 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=6.00..6.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:2  (slice2; segments: 2)  (cost=0.00..6.00 rows=100 width=16) (never executed)
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.005 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.790 ms
(14 rows)

:explain select * from d2 a join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.01..4.59 rows=7 width=28) (actual time=0.932..0.932 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..4.45 rows=4 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.975 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes avg x 2 workers, 40K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.216 ms
(12 rows)

:explain select * from d2 a join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.01..4.96 rows=7 width=24) (actual time=0.887..0.888 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..4.83 rows=4 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.003 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes avg x 2 workers, 40K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.120 ms
(12 rows)

:explain select * from d2 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.196..0.196 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.893 ms
(11 rows)

:explain select * from d2 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.189..0.189 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.869 ms
(11 rows)

:explain select * from d2 a join r2 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.01..1080.77 rows=72 width=28) (actual time=0.858..0.858 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1079.35 rows=36 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.367 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes avg x 2 workers, 40K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.099 ms
(12 rows)

:explain select * from d2 a join r2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.01..1345.75 rows=17 width=24) (actual time=0.967..0.967 rows=0 loops=1)
   ->  Hash Join  (cost=1.01..1345.43 rows=9 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.398 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 40K bytes avg x 2 workers, 40K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.225 ms
(12 rows)

:explain select * from r2 a join t2 b using (c1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=8.50..1219.47 rows=7110 width=28) (actual time=3.041..3.041 rows=0 loops=1)
   ->  Hash Join  (cost=8.50..1077.27 rows=3555 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=6.00..6.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:2  (slice2; segments: 2)  (cost=0.00..6.00 rows=100 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 1.862 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4117K bytes avg x 2 workers, 4117K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.476 ms
(14 rows)

:explain select * from r2 a join t2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=9.00..1193.82 rows=17 width=24) (actual time=3.167..3.168 rows=0 loops=1)
   ->  Hash Join  (cost=9.00..1193.50 rows=9 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=6.00..6.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:2  (slice2; segments: 2)  (cost=0.00..6.00 rows=100 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.220 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.654 ms
(14 rows)

:explain select * from r2 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.245..0.245 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.075 ms
(11 rows)

:explain select * from r2 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.180..0.180 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.943 ms
(11 rows)

:explain select * from r2 a join r2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.821..1.821 rows=0 loops=2)
   ->  Hash Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.395 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.527 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.526 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.498 ms
(17 rows)

:explain select * from r2 a join r2 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3299.50..1269741.05 rows=5056 width=24) (actual time=2.001..2.001 rows=0 loops=2)
   ->  Hash Join  (cost=3299.50..1269741.05 rows=1686 width=24) (actual time=0.000..3.243 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.378 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.377 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.819 ms
(17 rows)

-- x1 left join y1
:explain select * from t1 a left join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.278..0.278 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.021 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.543 ms
(13 rows)

:explain select * from t1 a left join t1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.172..0.172 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.907 ms
(11 rows)

:explain select * from t1 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.952 ms
(11 rows)

:explain select * from t1 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.183..0.183 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.077 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.076 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.982 ms
(11 rows)

:explain select * from t1 a left join r1 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1080.77 rows=72 width=28) (actual time=1.863..1.864 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.01..1079.35 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.761 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4121K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.060 ms
(12 rows)

:explain select * from t1 a left join r1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.01..1345.75 rows=17 width=24) (actual time=2.115..2.115 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.01..1345.43 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.902 ms
   (slice0)    Executor memory: 40K bytes.
   (slice1)    Executor memory: 4125K bytes (seg0).  Work_mem: 4096K bytes max.
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.387 ms
(12 rows)

:explain select * from d1 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.09 rows=4 width=28) (actual time=3.743..3.743 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.03..2.09 rows=2 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice1; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 0.900 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 4.234 ms
(18 rows)

:explain select * from d1 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1.01..2.08 rows=4 width=24) (actual time=2.053..2.053 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.01..2.08 rows=2 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice1; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 1.369 ms
   (slice0)    Executor memory: 127K bytes.
   (slice1)    Executor memory: 42K bytes (seg0).
   (slice2)    Executor memory: 4176K bytes (seg0).
 Memory used:  128000kB
 Optimizer: legacy query optimizer
 Execution time: 2.750 ms
(15 rows)

:explain select * from d1 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.205..0.205 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.985 ms
(11 rows)

:explain select * from d1 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.906 ms
(11 rows)

:explain select * from d1 a left join r1 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2502.79 rows=72 width=28) (actual time=2.898..2.898 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2501.37 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.840 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.382 ms
(18 rows)

:explain select * from d1 a left join r1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2767.77 rows=17 width=24) (actual time=2.991..2.991 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2767.45 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.972 ms
   (slice0)    Executor memory: 47K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.308 ms
(18 rows)

:explain select * from r1 a left join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.267..0.267 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.114 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.114 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.601 ms
(13 rows)

:explain select * from r1 a left join t1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.282..0.282 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.023 ms
(14 rows)

:explain select * from r1 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.230..0.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.015 ms
(11 rows)

:explain select * from r1 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.194..0.194 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.101 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.101 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.979 ms
(11 rows)

:explain select * from r1 a left join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.245..0.245 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.549 ms
(13 rows)

:explain select * from r1 a left join r1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.230..0.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.448 ms
(13 rows)

-- x1 left join y2
:explain select * from t1 a left join t2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.409..1.409 rows=0 loops=2)
   ->  Hash Right Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.453 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.737 ms
(13 rows)

:explain select * from t1 a left join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..4.98 rows=7 width=24) (actual time=2.189..2.190 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..4.85 rows=4 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on t1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.055 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.458 ms
(15 rows)

:explain select * from t1 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.201..0.201 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.105 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.104 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.996 ms
(11 rows)

:explain select * from t1 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.192..0.192 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.024 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.024 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.024 ms
(11 rows)

:explain select * from t1 a left join r2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.427..1.427 rows=0 loops=2)
   ->  Hash Right Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.190 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.057 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.056 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.685 ms
(13 rows)

:explain select * from t1 a left join r2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.449..1.449 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.436 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.024 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.813 ms
(14 rows)

:explain select * from d1 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..6.61 rows=7 width=28) (actual time=3.099..3.100 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..6.47 rows=7 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.222 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.709 ms
(18 rows)

:explain select * from d1 a left join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..4.98 rows=7 width=24) (actual time=2.430..2.430 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..4.85 rows=4 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.091 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.969 ms
(15 rows)

:explain select * from d1 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.230..0.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.013 ms
(11 rows)

:explain select * from d1 a left join d2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=2.06..2.06 rows=4 width=24) (actual time=0.977..0.978 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.01..2.06 rows=4 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.564 ms
   (slice0)    Executor memory: 42K bytes.
   (slice1)    Executor memory: 41K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 2.245 ms
(12 rows)

:explain select * from d1 a left join r2 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2502.79 rows=72 width=28) (actual time=2.935..2.936 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2501.37 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..2233.00 rows=35550 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.359 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.474 ms
(18 rows)

:explain select * from d1 a left join r2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2767.77 rows=17 width=24) (actual time=2.793..2.794 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2767.45 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:1  (slice2; segments: 2)  (cost=0.00..2233.00 rows=35550 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.454 ms
   (slice0)    Executor memory: 47K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.294 ms
(18 rows)

:explain select * from r1 a left join t2 b using (c1);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=6.25..3136.92 rows=71100 width=28) (actual time=2.880..2.881 rows=0 loops=1)
   ->  Hash Left Join  (cost=6.25..1714.92 rows=71100 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.304 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.307 ms
(14 rows)

:explain select * from r1 a left join t2 b using (c1, c2);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=6.50..3323.84 rows=71100 width=24) (actual time=2.733..2.734 rows=0 loops=1)
   ->  Hash Left Join  (cost=6.50..1901.84 rows=71100 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.425 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4125K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.149 ms
(14 rows)

:explain select * from r1 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.175..0.175 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.921 ms
(11 rows)

:explain select * from r1 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.202..0.202 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.033 ms
(11 rows)

:explain select * from r1 a left join r2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.422..1.422 rows=0 loops=2)
   ->  Hash Right Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.366 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.037 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.028 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.668 ms
(13 rows)

:explain select * from r1 a left join r2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..3798717.50 rows=71100 width=24) (actual time=1.442..1.442 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..3798717.50 rows=23700 width=24) (actual time=0.000..2.549 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.031 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.610 ms
(13 rows)

-- x2 left join y1
:explain select * from t2 a left join t1 b using (c1);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.05..7.43 rows=100 width=28) (actual time=2.142..2.142 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.05..5.43 rows=50 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.808 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.448 ms
(14 rows)

:explain select * from t2 a left join t1 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=3299.50..1268979.50 rows=71100 width=24) (actual time=1.287..1.287 rows=0 loops=2)
   ->  Hash Left Join  (cost=3299.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.759 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..0.943 rows=0 loops=1)
               ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.942 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.922 ms
(14 rows)

:explain select * from t2 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.09 rows=4 width=28) (actual time=3.297..3.297 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.03..2.09 rows=2 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 1.779 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes avg x 2 workers, 44K bytes max (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: legacy query optimizer
 Execution time: 4.335 ms
(18 rows)

:explain select * from t2 a left join d1 b using (c1, c2);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..7.79 rows=100 width=24) (actual time=2.145..2.146 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.03..5.79 rows=50 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.154 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4125K bytes avg x 2 workers, 4125K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.499 ms
(15 rows)

:explain select * from t2 a left join r1 b using (c1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=6.25..2639.22 rows=7110 width=28) (actual time=2.972..2.973 rows=0 loops=1)
   ->  Hash Right Join  (cost=6.25..2497.02 rows=7110 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=100 width=16) (never executed)
               ->  Redistribute Motion 2:1  (slice3; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.342 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes (seg0).
   (slice3)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.406 ms
(18 rows)

:explain select * from t2 a left join r1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.105..1.105 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..1.888 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.969 ms
(14 rows)

:explain select * from d2 a left join t1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.09 rows=4 width=28) (actual time=3.858..3.858 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.03..2.09 rows=2 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 1:1  (slice1; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 1.162 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: legacy query optimizer
 Execution time: 4.865 ms
(18 rows)

:explain select * from d2 a left join t1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1.01..2.08 rows=4 width=24) (actual time=3.928..3.928 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.01..2.08 rows=2 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 1:1  (slice1; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.00..1.00 rows=1 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 1.665 ms
   (slice0)    Executor memory: 127K bytes.
   (slice1)    Executor memory: 42K bytes (seg0).
   (slice2)    Executor memory: 4176K bytes (seg0).
 Memory used:  128000kB
 Optimizer: legacy query optimizer
 Execution time: 4.733 ms
(15 rows)

:explain select * from d2 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.214..0.214 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.074 ms
(11 rows)

:explain select * from d2 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.184..0.184 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.981 ms
(11 rows)

:explain select * from d2 a left join r1 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2502.79 rows=72 width=28) (actual time=3.524..3.524 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2501.37 rows=72 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.848 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.875 ms
(18 rows)

:explain select * from d2 a left join r1 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1.03..2767.77 rows=17 width=24) (actual time=3.013..3.013 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2767.45 rows=17 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=71100 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.986 ms
   (slice0)    Executor memory: 47K bytes.
   (slice1)    Executor memory: 4122K bytes (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.466 ms
(18 rows)

:explain select * from r2 a left join t1 b using (c1);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.05..3211.68 rows=71100 width=28) (actual time=2.326..2.327 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.05..1789.68 rows=35550 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.516 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4121K bytes avg x 2 workers, 4121K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.842 ms
(14 rows)

:explain select * from r2 a left join t1 b using (c1, c2);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.06..3478.31 rows=71100 width=24) (actual time=2.301..2.302 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.06..2056.31 rows=35550 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.03..1.03 rows=1 width=16) (never executed)
               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.03 rows=2 width=16) (never executed)
                     ->  Seq Scan on t1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.705 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4125K bytes avg x 2 workers, 4125K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.650 ms
(14 rows)

:explain select * from r2 a left join d1 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.09 rows=4 width=28) (actual time=3.868..3.868 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.03..2.09 rows=2 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 1.055 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes avg x 2 workers, 44K bytes max (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: legacy query optimizer
 Execution time: 4.679 ms
(18 rows)

:explain select * from r2 a left join d1 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=1.03..2.10 rows=4 width=24) (actual time=3.515..3.515 rows=0 loops=1)
   ->  Hash Left Join  (cost=1.03..2.10 rows=2 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..1.02 rows=1 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning time: 2.872 ms
   (slice0)    Executor memory: 135K bytes.
   (slice1)    Executor memory: 44K bytes avg x 2 workers, 44K bytes max (seg0).
   (slice2)    Executor memory: 44K bytes (seg0).
   (slice3)    Executor memory: 4184K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 4.259 ms
(18 rows)

:explain select * from r2 a left join r1 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.945..1.945 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.466 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.634 rows=0 loops=1)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.634 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.749 ms
(17 rows)

:explain select * from r2 a left join r1 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=3299.50..1270401.50 rows=71100 width=24) (actual time=2.230..2.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=3299.50..1270401.50 rows=23700 width=24) (actual time=0.000..3.825 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.693 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..0.810 rows=0 loops=1)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.808 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.073 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 5.359 ms
(17 rows)

-- x2 left join y2
:explain select * from t2 a left join t2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.972..1.972 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.288 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.506 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.505 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.784 ms
(17 rows)

:explain select * from t2 a left join t2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.167..0.167 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.954 ms
(11 rows)

:explain select * from t2 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.216..0.216 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.063 ms
(11 rows)

:explain select * from t2 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.196..0.196 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.968 ms
(11 rows)

:explain select * from t2 a left join r2 b using (c1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=6.25..2639.22 rows=7110 width=28) (actual time=2.973..2.973 rows=0 loops=1)
   ->  Hash Right Join  (cost=6.25..2497.02 rows=3555 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=35550 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=5.00..5.00 rows=50 width=16) (never executed)
               ->  Redistribute Motion 2:2  (slice3; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 1.852 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.415 ms
(18 rows)

:explain select * from t2 a left join r2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.633..1.633 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.559 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.862 ms
(14 rows)

:explain select * from d2 a left join t2 b using (c1);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..6.61 rows=7 width=28) (actual time=2.938..2.939 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..6.47 rows=4 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.842 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.396 ms
(18 rows)

:explain select * from d2 a left join t2 b using (c1, c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..4.98 rows=7 width=24) (actual time=2.425..2.425 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..4.85 rows=4 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice2; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 2.118 ms
   (slice0)    Executor memory: 43K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.716 ms
(15 rows)

:explain select * from d2 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.206..0.206 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.946 ms
(11 rows)

:explain select * from d2 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.192..0.192 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.014 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.883 ms
(11 rows)

:explain select * from d2 a left join r2 b using (c1);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..2502.79 rows=72 width=28) (actual time=2.207..2.208 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2501.37 rows=36 width=28) (never executed)
         Hash Cond: (b.c1 = a.c1)
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=35550 width=16) (never executed)
               Hash Key: b.c1
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1
                     ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.306 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4119K bytes avg x 2 workers, 4119K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.961 ms
(18 rows)

:explain select * from d2 a left join r2 b using (c1, c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1.03..2767.77 rows=17 width=24) (actual time=2.178..2.179 rows=0 loops=1)
   ->  Hash Right Join  (cost=1.03..2767.45 rows=9 width=24) (never executed)
         Hash Cond: ((b.c1 = a.c1) AND (b.c2 = a.c2))
         ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=35550 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=1.02..1.02 rows=1 width=16) (never executed)
               ->  Redistribute Motion 1:2  (slice3; segments: 1)  (cost=0.00..1.02 rows=1 width=16) (never executed)
                     Hash Key: a.c1, a.c2
                     ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=16) (never executed)
 Planning Time: 1.456 ms
   (slice0)    Executor memory: 47K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 37K bytes avg x 2 workers, 37K bytes max (seg0).
   (slice3)    Executor memory: 37K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 3.731 ms
(18 rows)

:explain select * from r2 a left join t2 b using (c1);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=8.50..3139.17 rows=71100 width=28) (actual time=2.973..2.974 rows=0 loops=1)
   ->  Hash Left Join  (cost=8.50..1717.17 rows=35550 width=28) (never executed)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=6.00..6.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:2  (slice2; segments: 2)  (cost=0.00..6.00 rows=100 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 1.862 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4122K bytes avg x 2 workers, 4122K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 4.475 ms
(14 rows)

:explain select * from r2 a left join t2 b using (c1, c2);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=9.00..3326.34 rows=71100 width=24) (actual time=3.566..3.567 rows=0 loops=1)
   ->  Hash Left Join  (cost=9.00..1904.34 rows=35550 width=24) (never executed)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=35550 width=16) (never executed)
         ->  Hash  (cost=6.00..6.00 rows=100 width=16) (never executed)
               ->  Broadcast Motion 2:2  (slice2; segments: 2)  (cost=0.00..6.00 rows=100 width=16) (never executed)
                     ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=50 width=16) (never executed)
 Planning Time: 2.022 ms
   (slice0)    Executor memory: 45K bytes.
   (slice1)    Executor memory: 4125K bytes avg x 2 workers, 4125K bytes max (seg0).  Work_mem: 4096K bytes max.
   (slice2)    Executor memory: 36K bytes avg x 2 workers, 36K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution Time: 5.018 ms
(14 rows)

:explain select * from r2 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.237..0.237 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.103 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.022 ms
(11 rows)

:explain select * from r2 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.171..0.171 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.923 ms
(11 rows)

:explain select * from r2 a left join r2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.649..2.649 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..4.693 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.019 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.019 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..3.142 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..3.141 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.012 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.083 ms
(17 rows)

:explain select * from r2 a left join r2 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3299.50..1270401.50 rows=71100 width=24) (actual time=2.026..2.026 rows=0 loops=2)
   ->  Hash Left Join  (cost=3299.50..1270401.50 rows=23700 width=24) (actual time=0.000..3.432 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.607 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.445 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.444 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.955 ms
(17 rows)

--
-- insert
--
insert into t1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into d1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
  2 |   
(6 rows)

begin;
insert into t1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into t2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

rollback;
begin;
insert into t1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into d1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into t2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
 11 |   
 12 |   
 13 |   
 14 |   
 19 |   
  1 |   
  2 |   
  3 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 15 |   
 16 |   
 17 |   
 18 |   
 20 |   
(20 rows)

insert into d2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  4 |   
  6 |   
 14 |   
 15 |   
 16 |   
 18 |   
 19 |   
  1 |   
  2 |   
  3 |   
  5 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 17 |   
 20 |   
(20 rows)

rollback;
begin;
insert into t1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(12 rows)

insert into t1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  1 |   
  2 |   
  3 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into t2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  2
    |  4
    |  6
    |  1
    |  3
    |  5
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  2 |   
  1 |   
  3 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(6 rows)

insert into d1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(30 rows)

insert into d1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(24 rows)

insert into d2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(42 rows)

insert into r1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  4
    |  5
    |  6
    |  3
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  1 |   
  2 |   
  3 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  1 |   
  2 |   
  3 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  6 |   
  1 |   
  2 |   
  5 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  6 |   
    |  5
  5 |   
  4 |   
  5 |   
  4 |   
  6 |   
  1 |   
  2 |   
  3 |   
  6 |   
  1 |   
  2 |   
  3 |   
  6 |   
  3 |   
  4 |   
  2 |   
  3 |   
  4 |   
  5 |   
    |  1
    |  2
    |  4
    |  6
  4 |   
  5 |   
  1 |   
  2 |   
  1 |   
  3 |   
  5 |   
    |  3
  6 |   
(36 rows)

rollback;
--
-- pg_relation_size() dispatches an internal query, to fetch the relation's
-- size on each segment. The internal query doesn't need to be part of the
-- distributed transactin. Test that we correctly issue two-phase commit in
-- those segments that are affected by the INSERT, and that we don't try
-- to perform distributed commit on the other segments.
--
insert into r1 (c4) values (pg_relation_size('r2'));
--
-- copy to a partial replicated table from file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_from (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

copy partial_rpt_from (c1, c2) from stdin with delimiter ',';
select * from gp_dist_random('partial_rpt_from');
 c1 | c2 
----+----
  1 |  2
  1 |  2
(2 rows)

--
-- copy from a partial replicated table to file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_to (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into partial_rpt_to values (1,1);
copy partial_rpt_to to stdout;
1	1
-- change a replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- change to another replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- start_ignore
-- We need to do a cluster expansion which will check if there are partial
-- tables, we need to drop the partial tables to keep the cluster expansion
-- run correctly.
reset search_path;
drop schema test_partial_table cascade;
NOTICE:  drop cascades to 7 other objects
DETAIL:  drop cascades to table test_partial_table.t1
drop cascades to table test_partial_table.d1
drop cascades to table test_partial_table.r1
drop cascades to table test_partial_table.t2
drop cascades to table test_partial_table.d2
drop cascades to table test_partial_table.r2
drop cascades to table test_partial_table.partial_rpt
-- end_ignore
